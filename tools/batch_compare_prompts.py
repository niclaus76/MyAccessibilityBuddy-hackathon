#!/usr/bin/env python3
"""
MyAccessibilityBuddy - Batch Prompt Comparison Script

This script processes all images in input/images with three different prompts:
1. base_prompt.txt
2. alt-text-improved.txt
3. main_prompt.txt

Output: CSV file with comparison of alt-text generated by each prompt.
"""

import json
import csv
import os
import sys
import subprocess
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List

# ANSI color codes
class Colors:
    GREEN = '\033[0;32m'
    BLUE = '\033[0;34m'
    YELLOW = '\033[1;33m'
    RED = '\033[0;31m'
    NC = '\033[0m'  # No Color

# Configuration
BACKEND_DIR = Path("backend")
CONFIG_FILE = BACKEND_DIR / "config" / "config.json"
IMAGES_DIR = Path("input/images")
CONTEXT_DIR = Path("input/context")
OUTPUT_DIR = Path("output/alt-text")
PROMPT_DIR = Path("prompt")

# Prompt files to test
PROMPTS = [
    {"file": "prompt_v0.txt", "label": "v0: base prompt"},
    {"file": "prompt_v1.txt", "label": "v1: With image classification"},
    {"file": "prompt_v2.txt", "label": "v2: With image classification and workflow"},
    {"file": "prompt_v3.txt", "label": "v3: With extended image classification and workflow"},
    {"file": "prompt_v4.txt", "label": "v4: with extended image classification, workflow and security"}
]

def print_header(text: str):
    """Print a formatted header."""
    print(f"\n{Colors.BLUE}{'='*70}{Colors.NC}")
    print(f"{Colors.BLUE}{text.center(70)}{Colors.NC}")
    print(f"{Colors.BLUE}{'='*70}{Colors.NC}\n")

def print_success(text: str):
    """Print success message."""
    print(f"{Colors.GREEN}✓ {text}{Colors.NC}")

def print_error(text: str):
    """Print error message."""
    print(f"{Colors.RED}✗ {text}{Colors.NC}")

def print_info(text: str):
    """Print info message."""
    print(f"{Colors.BLUE}→ {text}{Colors.NC}")

def print_warning(text: str):
    """Print warning message."""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.NC}")

def check_environment():
    """Check if the environment is set up correctly."""
    print_header("Environment Check")

    # Check if we're in project root
    if not CONFIG_FILE.exists():
        print_error(f"Configuration file not found: {CONFIG_FILE}")
        print_error("Please run this script from the project root directory")
        return False

    print_success("Project root directory verified")

    # Check images directory
    if not IMAGES_DIR.exists():
        print_error(f"Images directory not found: {IMAGES_DIR}")
        return False

    # Count images
    image_extensions = ['*.jpg', '*.jpeg', '*.png', '*.gif', '*.webp', '*.svg', '*.bmp', '*.tiff']
    images = []
    for ext in image_extensions:
        images.extend(IMAGES_DIR.glob(ext))
        images.extend(IMAGES_DIR.glob(ext.upper()))

    if len(images) == 0:
        print_error(f"No images found in {IMAGES_DIR}")
        return False

    print_success(f"Found {len(images)} images to process")

    # Check context directory
    if CONTEXT_DIR.exists():
        contexts = list(CONTEXT_DIR.glob("*.txt"))
        print_success(f"Found {len(contexts)} context files")
    else:
        print_warning("No context directory found - processing without context")

    # Check prompt files
    print_info("Checking prompt files...")
    for prompt in PROMPTS:
        prompt_path = PROMPT_DIR / prompt['file']
        if not prompt_path.exists():
            print_error(f"Prompt file not found: {prompt_path}")
            return False
        print_success(f"  {prompt['file']}")

    return True

def backup_config():
    """Backup the configuration file."""
    backup_path = CONFIG_FILE.with_suffix('.json.backup')
    shutil.copy2(CONFIG_FILE, backup_path)
    print_success(f"Configuration backed up to {backup_path}")
    return backup_path

def restore_config(backup_path: Path):
    """Restore the configuration file from backup."""
    if backup_path.exists():
        shutil.copy2(backup_path, CONFIG_FILE)
        backup_path.unlink()
        print_success("Configuration restored")

def update_config_prompt(prompt_file: str):
    """Update the configuration to use a specific prompt file."""
    with open(CONFIG_FILE, 'r') as f:
        config = json.load(f)

    config['prompt']['files'] = [prompt_file]

    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

    print_info(f"Updated configuration to use: {prompt_file}")

def clear_output_directory():
    """Clear the output directory."""
    if OUTPUT_DIR.exists():
        for file in OUTPUT_DIR.glob("*.json"):
            file.unlink()
        print_success("Cleared output directory")

def run_batch_processing():
    """Run the batch processing command."""
    print_info("Running batch processing...")

    try:
        # Change to backend directory and run the command
        result = subprocess.run(
            ["python3", "app.py", "--process-all", "--language", "en"],
            cwd=BACKEND_DIR,
            capture_output=True,
            text=True,
            timeout=3600  # 1 hour timeout
        )

        if result.returncode != 0:
            print_error(f"Batch processing failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error output: {result.stderr}")
            return False

        print_success("Batch processing completed")
        return True

    except subprocess.TimeoutExpired:
        print_error("Batch processing timed out (1 hour limit)")
        return False
    except Exception as e:
        print_error(f"Error running batch processing: {e}")
        return False

def extract_results() -> Dict[str, str]:
    """Extract alt-text results from JSON files."""
    results = {}

    for json_file in OUTPUT_DIR.glob("*.json"):
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                # Use image_id from JSON, or fallback to filename
                image_file = data.get('image_id', json_file.stem)
                # The field is 'proposed_alt_text' not 'alt_text'
                alt_text = data.get('proposed_alt_text', data.get('alt_text', ''))
                results[image_file] = alt_text
        except Exception as e:
            print_warning(f"Error reading {json_file.name}: {e}")

    return results

def generate_csv(all_results: Dict[str, Dict[str, str]], output_path: Path):
    """Generate CSV comparison file."""
    print_header("Generating CSV Report")

    # Get all unique image filenames
    all_images = set()
    for prompt_results in all_results.values():
        all_images.update(prompt_results.keys())

    sorted_images = sorted(all_images)

    # Write CSV
    with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile, quoting=csv.QUOTE_ALL)

        # Write header
        header = ['Image Filename']
        for prompt in PROMPTS:
            header.append(f"Alt Text ({prompt['label']})")
        writer.writerow(header)

        # Write data rows
        for image in sorted_images:
            row = [image]
            for prompt in PROMPTS:
                alt_text = all_results.get(prompt['label'], {}).get(image, '')
                row.append(alt_text)
            writer.writerow(row)

    print_success(f"CSV file created: {output_path}")
    print_success(f"Total images: {len(sorted_images)}")

def main():
    """Main execution function."""
    print_header("MyAccessibilityBuddy - Batch Prompt Comparison")

    # Check environment
    if not check_environment():
        sys.exit(1)

    # Create output directory for CSV
    output_csv_dir = Path("output")
    output_csv_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_csv = output_csv_dir / f"prompt_comparison_{timestamp}.csv"

    # Backup configuration
    backup_path = backup_config()

    # Store all results
    all_results = {}

    try:
        # Process with each prompt
        for i, prompt in enumerate(PROMPTS, 1):
            print_header(f"Processing with: {prompt['label']} ({i}/{len(PROMPTS)})")

            # Update configuration
            update_config_prompt(prompt['file'])

            # Clear previous output
            clear_output_directory()

            # Run batch processing
            if not run_batch_processing():
                print_error(f"Failed to process with {prompt['label']}")
                continue

            # Extract results
            print_info("Extracting results...")
            results = extract_results()
            all_results[prompt['label']] = results
            print_success(f"Extracted {len(results)} results for {prompt['label']}")

        # Generate CSV report
        generate_csv(all_results, output_csv)

        # Summary
        print_header("Processing Complete!")
        print_success(f"Results saved to: {output_csv}")

        # Show statistics
        total_images = len(set().union(*[set(r.keys()) for r in all_results.values()]))
        print(f"\n{Colors.BLUE}Statistics:{Colors.NC}")
        print(f"  Total images processed: {total_images}")
        for prompt in PROMPTS:
            count = len(all_results.get(prompt['label'], {}))
            print(f"  {prompt['label']}: {count} alt-texts generated")

        print(f"\n{Colors.YELLOW}Open the CSV file to compare alt-text generated by different prompts{Colors.NC}\n")

    except KeyboardInterrupt:
        print_error("\n\nProcess interrupted by user")
        sys.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    finally:
        # Restore configuration
        restore_config(backup_path)

if __name__ == "__main__":
    main()
